# AVL-дерево

AVL-дерево — это самобалансирующееся двоичное дерево поиска, которое гарантирует, что высота дерева всегда остается логарифмической относительно количества его узлов. Это позволяет выполнять операции поиска, вставки и удаления с эффективностью `O(log n)`. Основной особенностью AVL-дерева является поддержание сбалансированности после каждой операции вставки или удаления.

## Как работает AVL-дерево

### Вставка элемента

1. **Поиск места для вставки**: 
   - Начинаем с корня дерева и перемещаемся вниз по дереву, сравнивая ключи.
   - Если ключ меньше текущего узла, переходим в левое поддерево; если больше — в правое.

2. **Создание нового узла**: 
   - Если достигнут конец (узел, равный `None`), создается новый узел с указанным ключом.

3. **Балансировка дерева**: 
   - После вставки обновляются высоты узлов.
   - Проверяется баланс каждого узла на пути к корню. Если баланс нарушен, выполняются вращения для восстановления балансировки.

### Удаление элемента

1. **Поиск узла для удаления**: 
   - Сначала ищется узел, который нужно удалить, аналогично вставке.
   
2. **Удаление узла**: 
   - Если узел не имеет детей, он просто удаляется.
   - Если узел имеет одного ребенка, заменяем его на этого ребенка.
   - Если узел имеет двоих детей, находят минимальный узел в правом поддереве, копируют его значение в удаляемый узел и удаляют минимальный узел.

3. **Балансировка дерева**: 
   - После удаления обновляются высоты узлов и проверяется баланс. Если баланс нарушен, выполняются соответствующие вращения.

## Классы AVLNode и AVLTree

### Класс `AVLNode`

Класс `AVLNode` представляет узел AVL-дерева. Каждый узел содержит:

- `key`: значение узла.
- `height`: высота узла (по умолчанию равна 1).
- `left`: указатель на левое поддерево (по умолчанию `None`).
- `right`: указатель на правое поддерево (по умолчанию `None`).

```python
class AVLNode:
    def __init__(self, key):
        self.key = key
        self.height = 1
        self.left = None
        self.right = None
```

## Класс AVLTree

Класс `AVLTree` управляет операциями над деревом. Основные методы и их назначения:

- **`__init__`**: Конструктор, инициализирующий корень дерева и счетчик вращений.
- **`get_height`**: Возвращает высоту узла или 0, если узел равен `None`.
- **`update_height`**: Обновляет высоту узла на основе высот его дочерних узлов.
- **`get_balance`**: Вычисляет баланс узла, разность высот левого и правого поддеревьев.
- **`left_rotate` и `right_rotate`**: Выполняют левое и правое вращения соответственно, чтобы восстановить баланс.
- **`balance`**: Проверяет баланс узла и выполняет необходимые вращения.
- **`insert`**: Рекурсивно вставляет ключ в дерево и балансирует его.
- **`insert_key`**: Упрощенная функция для вставки ключа, начинающая с корня.
- **`find_min`**: Находит узел с минимальным значением в поддереве.
- **`delete`**: Рекурсивно удаляет узел с указанным ключом и балансирует дерево.
- **`delete_key`**: Упрощенная функция для удаления ключа, начинающая с корня.

## Пример работы

Когда происходит операция вставки или удаления, высота узлов обновляется, и при необходимости выполняются вращения для поддержания сбалансированности дерева. Это позволяет обеспечивать эффективные операции поиска, вставки и удаления в AVL-дереве.

Таким образом, AVL-дерево сохраняет свои свойства самобалансировки, что делает его одним из самых эффективных способов работы с динамическими наборами данных.
